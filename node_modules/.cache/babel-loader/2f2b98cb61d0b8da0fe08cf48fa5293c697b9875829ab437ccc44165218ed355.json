{"ast":null,"code":"import Condition from './condition.js';\nimport { CONFIG_PARAMS } from './configuration.js';\nimport { cloneDeep } from '../internal/utils/cloneDeep.js';\nimport { camelCase, contains, difference } from \"./utils/legacyBaseUtil.js\";\nimport { snakeCase } from \"./utils/snakeCase.js\";\nimport Expression from './expression.js';\nimport Layer from './legacyLayer/layer.js';\nimport TextLayer from './legacyLayer/textlayer.js';\nimport SubtitlesLayer from './legacyLayer/subtitleslayer.js';\nimport FetchLayer from './legacyLayer/fetchlayer.js';\nimport { isObject } from \"./utils/isObject.js\";\nimport { isString } from \"../internal/utils/dataStructureUtils.js\";\nimport { isEmpty } from \"./utils/isEmpty.js\";\nimport { isFunction } from \"./utils/isFunction.js\";\nimport { identity, withCamelCaseKeys } from \"./utils/legacyBaseUtil.js\";\n/**\n * A list of keys used by the url() function.\n * @private\n */\nexport const URL_KEYS = ['accessibility', 'api_secret', 'auth_token', 'cdn_subdomain', 'cloud_name', 'cname', 'format', 'placeholder', 'private_cdn', 'resource_type', 'secure', 'secure_cdn_subdomain', 'secure_distribution', 'shorten', 'sign_url', 'signature', 'ssl_detected', 'type', 'url_suffix', 'use_root_path', 'version'];\n/**\n * Assign key, value to target, when value is not null.<br>\n *   This function mutates the target!\n * @param {object} target the object to assign the values to\n * @param {object} sources one or more objects to get values from\n * @returns {object} the target after the assignment\n */\nfunction assignNotNull(target) {\n  for (var _len = arguments.length, sources = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    sources[_key - 1] = arguments[_key];\n  }\n  sources.forEach(source => {\n    Object.keys(source).forEach(key => {\n      // @ts-ignore\n      if (source[key] != null) {\n        // @ts-ignore\n        target[key] = source[key];\n      }\n    });\n  });\n  return target;\n}\n/**\n * Return true if all items in list are strings\n * @function Util.allString\n * @param {Array} list - an array of items\n */\nconst allStrings = function (list) {\n  return list.length && list.every(isString);\n};\n/**\n * Transformation parameters\n * Depends on 'util', 'transformation'\n */\nclass Param {\n  /**\n   * Represents a single parameter.\n   * @class Param\n   * @param {string} name - The name of the parameter in snake_case\n   * @param {string} shortName - The name of the serialized form of the parameter.\n   *                         If a value is not provided, the parameter will not be serialized.\n   * @param {function} [process=Util.identity ] - Manipulate origValue when value is called\n   * @ignore\n   */\n  constructor(name, shortName) {\n    let process = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : identity;\n    /**\n     * The name of the parameter in snake_case\n     * @member {string} Param#name\n     */\n    this.name = name;\n    /**\n     * The name of the serialized form of the parameter\n     * @member {string} Param#shortName\n     */\n    this.shortName = shortName;\n    /**\n     * Manipulate origValue when value is called\n     * @member {function} Param#process\n     */\n    this.process = process;\n  }\n  /**\n   * Set a (unprocessed) value for this parameter\n   * @function Param#set\n   * @param {*} origValue - the value of the parameter\n   * @return {Param} self for chaining\n   */\n  set(origValue) {\n    this.origValue = origValue;\n    return this;\n  }\n  /**\n   * Generate the serialized form of the parameter\n   * @function Param#serialize\n   * @return {string} the serialized form of the parameter\n   */\n  serialize() {\n    var val, valid;\n    val = this.value();\n    valid = Array.isArray(val) || isObject(val) || isString(val) ? !isEmpty(val) : val != null;\n    if (this.shortName != null && valid) {\n      return `${this.shortName}_${val}`;\n    } else {\n      return '';\n    }\n  }\n  /**\n   * Return the processed value of the parameter\n   * @function Param#value\n   */\n  value() {\n    return this.process(this.origValue);\n  }\n  static norm_color(value) {\n    return value != null ? value.replace(/^#/, 'rgb:') : void 0;\n  }\n  static build_array(arg) {\n    if (arg == null) {\n      return [];\n    } else if (Array.isArray(arg)) {\n      return arg;\n    } else {\n      return [arg];\n    }\n  }\n  /**\n   * Covert value to video codec string.\n   *\n   * If the parameter is an object,\n   * @param {(string|Object)} param - the video codec as either a String or a Hash\n   * @return {string} the video codec string in the format codec:profile:level\n   * @example\n   * vc_[ :profile : [level]]\n   * or\n   { codec: 'h264', profile: 'basic', level: '3.1' }\n   * @ignore\n   */\n  static process_video_params(param) {\n    var video;\n    switch (param.constructor) {\n      case Object:\n        video = \"\";\n        if ('codec' in param) {\n          video = param.codec;\n          if ('profile' in param) {\n            video += \":\" + param.profile;\n            if ('level' in param) {\n              video += \":\" + param.level;\n            }\n          }\n        }\n        return video;\n      case String:\n        return param;\n      default:\n        return null;\n    }\n  }\n}\nclass ArrayParam extends Param {\n  /**\n   * A parameter that represents an array.\n   * @param {string} name - The name of the parameter in snake_case.\n   * @param {string} shortName - The name of the serialized form of the parameter\n   *                         If a value is not provided, the parameter will not be serialized.\n   * @param {string} [sep='.'] - The separator to use when joining the array elements together\n   * @param {function} [process=Util.identity ] - Manipulate origValue when value is called\n   * @class ArrayParam\n   * @extends Param\n   * @ignore\n   */\n  constructor(name, shortName) {\n    let sep = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '.';\n    let process = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;\n    super(name, shortName, process);\n    this.sep = sep;\n  }\n  serialize() {\n    if (this.shortName != null) {\n      let arrayValue = this.value();\n      if (isEmpty(arrayValue)) {\n        return '';\n      } else if (isString(arrayValue)) {\n        return `${this.shortName}_${arrayValue}`;\n      } else {\n        let flat = arrayValue.map(t => isFunction(t.serialize) ? t.serialize() : t).join(this.sep);\n        return `${this.shortName}_${flat}`;\n      }\n    } else {\n      return '';\n    }\n  }\n  value() {\n    if (Array.isArray(this.origValue)) {\n      return this.origValue.map(v => this.process(v));\n    } else {\n      return this.process(this.origValue);\n    }\n  }\n  set(origValue) {\n    if (origValue == null || Array.isArray(origValue)) {\n      return super.set(origValue);\n    } else {\n      return super.set([origValue]);\n    }\n  }\n}\nclass TransformationParam extends Param {\n  /**\n   * A parameter that represents a transformation\n   * @param {string} name - The name of the parameter in snake_case\n   * @param {string} [shortName='t'] - The name of the serialized form of the parameter\n   * @param {string} [sep='.'] - The separator to use when joining the array elements together\n   * @param {function} [process=Util.identity ] - Manipulate origValue when value is called\n   * @class TransformationParam\n   * @extends Param\n   * @ignore\n   */\n  constructor(name) {\n    let shortName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"t\";\n    let sep = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '.';\n    let process = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : undefined;\n    super(name, shortName, process);\n    this.sep = sep;\n  }\n  /**\n   * Generate string representations of the transformation.\n   * @returns {*} Returns either the transformation as a string, or an array of string representations.\n   */\n  serialize() {\n    let result = '';\n    const val = this.value();\n    if (isEmpty(val)) {\n      return result;\n    }\n    // val is an array of strings so join them\n    if (allStrings(val)) {\n      const joined = val.join(this.sep); // creates t1.t2.t3 in case multiple named transformations were configured\n      if (!isEmpty(joined)) {\n        // in case options.transformation was not set with an empty string (val != ['']);\n        result = `${this.shortName}_${joined}`;\n      }\n    } else {\n      // Convert val to an array of strings\n      result = val.map(t => {\n        if (isString(t) && !isEmpty(t)) {\n          return `${this.shortName}_${t}`;\n        }\n        if (isFunction(t.serialize)) {\n          return t.serialize();\n        }\n        if (isObject(t) && !isEmpty(t)) {\n          return new Transformation(t).serialize();\n        }\n        return undefined;\n      }).filter(t => t);\n    }\n    return result;\n  }\n  set(origValue1) {\n    this.origValue = origValue1;\n    if (Array.isArray(this.origValue)) {\n      return super.set(this.origValue);\n    } else {\n      return super.set([this.origValue]);\n    }\n  }\n}\nconst number_pattern = \"([0-9]*)\\\\.([0-9]+)|([0-9]+)\";\nconst offset_any_pattern = \"(\" + number_pattern + \")([%pP])?\";\nclass RangeParam extends Param {\n  /**\n   * A parameter that represents a range\n   * @param {string} name - The name of the parameter in snake_case\n   * @param {string} shortName - The name of the serialized form of the parameter\n   *                         If a value is not provided, the parameter will not be serialized.\n   * @param {function} [process=norm_range_value ] - Manipulate origValue when value is called\n   * @class RangeParam\n   * @extends Param\n   * @ignore\n   */\n  constructor(name, shortName) {\n    let process = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : RangeParam.norm_range_value;\n    super(name, shortName, process);\n  }\n  static norm_range_value(value) {\n    let offset = String(value).match(new RegExp('^' + offset_any_pattern + '$'));\n    if (offset) {\n      let modifier = offset[5] != null ? 'p' : '';\n      value = (offset[1] || offset[4]) + modifier;\n    }\n    return value;\n  }\n}\nclass RawParam extends Param {\n  constructor(name, shortName) {\n    let process = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : identity;\n    super(name, shortName, process);\n  }\n  serialize() {\n    return this.value();\n  }\n}\nclass LayerParam extends Param {\n  // Parse layer options\n  // @return [string] layer transformation string\n  // @private\n  value() {\n    if (this.origValue == null) {\n      return '';\n    }\n    let result;\n    if (this.origValue instanceof Layer) {\n      result = this.origValue;\n    } else if (isObject(this.origValue)) {\n      let layerOptions = withCamelCaseKeys(this.origValue);\n      // @ts-ignore\n      if (layerOptions.resourceType === \"text\" || layerOptions.text != null) {\n        result = new TextLayer(layerOptions);\n      } else {\n        // @ts-ignore\n        if (layerOptions.resourceType === \"subtitles\") {\n          result = new SubtitlesLayer(layerOptions);\n        } else {\n          // @ts-ignore\n          if (layerOptions.resourceType === \"fetch\" || layerOptions.url != null) {\n            result = new FetchLayer(layerOptions);\n          } else {\n            result = new Layer(layerOptions);\n          }\n        }\n      }\n    } else if (isString(this.origValue)) {\n      if (/^fetch:.+/.test(this.origValue)) {\n        result = new FetchLayer(this.origValue.substr(6));\n      } else {\n        result = this.origValue;\n      }\n    } else {\n      result = '';\n    }\n    return result.toString();\n  }\n  static textStyle(layer) {\n    return new TextLayer(layer).textStyleIdentifier();\n  }\n}\n/**\n * TransformationBase\n * Depends on 'configuration', 'parameters','util'\n * @internal\n */\nclass TransformationBase {\n  /**\n   * The base class for transformations.\n   * Members of this class are documented as belonging to the {@link Transformation} class for convenience.\n   * @class TransformationBase\n   */\n  constructor(options) {\n    /** @private */\n    /** @private */\n    let parent;\n    let trans;\n    parent = void 0;\n    trans = {};\n    /**\n     * Return an options object that can be used to create an identical Transformation\n     * @function Transformation#toOptions\n     * @return {Object} Returns a plain object representing this transformation\n     */\n    this.toOptions = withChain => {\n      let opt = {};\n      if (withChain == null) {\n        withChain = true;\n      }\n      // @ts-ignore\n      Object.keys(trans).forEach(key => opt[key] = trans[key].origValue);\n      assignNotNull(opt, this.otherOptions);\n      if (withChain && !isEmpty(this.chained)) {\n        let list = this.chained.map(tr => tr.toOptions());\n        list.push(opt);\n        opt = {};\n        assignNotNull(opt, this.otherOptions);\n        // @ts-ignore\n        opt.transformation = list;\n      }\n      return opt;\n    };\n    /**\n     * Set a parent for this object for chaining purposes.\n     *\n     * @function Transformation#setParent\n     * @param {Object} object - the parent to be assigned to\n     * @returns {Transformation} Returns this instance for chaining purposes.\n     */\n    this.setParent = object => {\n      parent = object;\n      if (object != null) {\n        // @ts-ignore\n        this.fromOptions(typeof object.toOptions === \"function\" ? object.toOptions() : void 0);\n      }\n      return this;\n    };\n    /**\n     * Returns the parent of this object in the chain\n     * @function Transformation#getParent\n     * @protected\n     * @return {Object} Returns the parent of this object if there is any\n     */\n    this.getParent = () => {\n      return parent;\n    };\n    // Helper methods to create parameter methods\n    // These methods are defined here because they access `trans` which is\n    // a private member of `TransformationBase`\n    /** @protected */\n    this.param = (value, name, abbr, defaultValue, process) => {\n      if (process == null) {\n        if (isFunction(defaultValue)) {\n          process = defaultValue;\n        } else {\n          process = identity;\n        }\n      }\n      // @ts-ignore\n      trans[name] = new Param(name, abbr, process).set(value);\n      return this;\n    };\n    /** @protected */\n    this.rawParam = function (value, name, abbr, defaultValue, process) {\n      process = lastArgCallback(arguments);\n      // @ts-ignore\n      trans[name] = new RawParam(name, abbr, process).set(value);\n      return this;\n    };\n    /** @protected */\n    this.rangeParam = function (value, name, abbr, defaultValue, process) {\n      process = lastArgCallback(arguments);\n      // @ts-ignore\n      trans[name] = new RangeParam(name, abbr, process).set(value);\n      return this;\n    };\n    /** @protected */\n    this.arrayParam = function (value, name, abbr) {\n      let sep = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \":\";\n      let defaultValue = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];\n      let process = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : undefined;\n      process = lastArgCallback(arguments);\n      // @ts-ignore\n      trans[name] = new ArrayParam(name, abbr, sep, process).set(value);\n      return this;\n    };\n    /** @protected */\n    this.transformationParam = function (value, name, abbr) {\n      let sep = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : \".\";\n      let defaultValue = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : undefined;\n      let process = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : undefined;\n      process = lastArgCallback(arguments);\n      // @ts-ignore\n      trans[name] = new TransformationParam(name, abbr, sep, process).set(value);\n      return this;\n    };\n    this.layerParam = function (value, name, abbr) {\n      // @ts-ignore\n      trans[name] = new LayerParam(name, abbr).set(value);\n      return this;\n    };\n    // End Helper methods\n    /**\n     * Get the value associated with the given name.\n     * Get the value associated with the given name.\n     * @function Transformation#getValue\n     * @param {string} name - the name of the parameter\n     * @return {*} the processed value associated with the given name\n     * @description Use {@link get}.origValue for the value originally provided for the parameter\n     */\n    this.getValue = function (name) {\n      // @ts-ignore\n      let value = trans[name] && trans[name].value();\n      return value != null ? value : this.otherOptions[name];\n    };\n    /**\n     * Get the parameter object for the given parameter name\n     * @function Transformation#get\n     * @param {string} name the name of the transformation parameter\n     * @returns {Param} the param object for the given name, or undefined\n     */\n    this.get = function (name) {\n      // @ts-ignore\n      return trans[name];\n    };\n    /**\n     * Remove a transformation option from the transformation.\n     * @function Transformation#remove\n     * @param {string} name - the name of the option to remove\n     * @return {*} Returns the option that was removed or null if no option by that name was found. The type of the\n     *              returned value depends on the value.\n     */\n    this.remove = function (name) {\n      var temp;\n      switch (false) {\n        // @ts-ignore\n        case trans[name] == null:\n          // @ts-ignore\n          temp = trans[name];\n          // @ts-ignore\n          delete trans[name];\n          return temp.origValue;\n        case this.otherOptions[name] == null:\n          temp = this.otherOptions[name];\n          delete this.otherOptions[name];\n          return temp;\n        default:\n          return null;\n      }\n    };\n    /**\n     * Return an array of all the keys (option names) in the transformation.\n     * @return {Array<string>} the keys in snakeCase format\n     */\n    this.keys = function () {\n      var key;\n      return function () {\n        var results;\n        results = [];\n        for (key in trans) {\n          if (key != null) {\n            results.push(key.match(VAR_NAME_RE) ? key : snakeCase(key));\n          }\n        }\n        return results;\n      }().sort();\n    };\n    /**\n     * Returns a plain object representation of the transformation. Values are processed.\n     * @function Transformation#toPlainObject\n     * @return {Object} the transformation options as plain object\n     */\n    this.toPlainObject = function () {\n      var hash, key, list;\n      hash = {};\n      for (key in trans) {\n        // @ts-ignore\n        hash[key] = trans[key].value();\n        // @ts-ignore\n        if (isObject(hash[key])) {\n          // @ts-ignore\n          hash[key] = cloneDeep(hash[key]);\n        }\n      }\n      if (!isEmpty(this.chained)) {\n        list = this.chained.map(tr => tr.toPlainObject());\n        list.push(hash);\n        hash = {\n          transformation: list\n        };\n      }\n      return hash;\n    };\n    /**\n     * Complete the current transformation and chain to a new one.\n     * In the URL, transformations are chained together by slashes.\n     * @function Transformation#chain\n     * @return {Transformation} Returns this transformation for chaining\n     * @example\n     * var tr = cloudinary.Transformation.new();\n     * tr.width(10).crop('fit').chain().angle(15).serialize()\n     * // produces \"c_fit,w_10/a_15\"\n     */\n    this.chain = function () {\n      var names, tr;\n      names = Object.getOwnPropertyNames(trans);\n      if (names.length !== 0) {\n        tr = new this.constructor(this.toOptions(false));\n        this.resetTransformations();\n        this.chained.push(tr);\n      }\n      return this;\n    };\n    this.resetTransformations = function () {\n      trans = {};\n      return this;\n    };\n    this.otherOptions = {};\n    this.chained = [];\n    this.fromOptions(options);\n  }\n  /**\n   * Merge the provided options with own's options\n   * @param {Object} [options={}] key-value list of options\n   * @returns {Transformation} Returns this instance for chaining\n   */\n  fromOptions() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (options instanceof TransformationBase) {\n      this.fromTransformation(options);\n    } else {\n      if (isString(options) || Array.isArray(options)) {\n        options = {\n          transformation: options\n        };\n      }\n      options = cloneDeep(options);\n      // Handling of \"if\" statements precedes other options as it creates a chained transformation\n      // @ts-ignore\n      if (options[\"if\"]) {\n        // @ts-ignore\n        this.set(\"if\", options[\"if\"]);\n        // @ts-ignore\n        delete options[\"if\"];\n      }\n      for (let key in options) {\n        // @ts-ignore\n        let opt = options[key];\n        if (opt != null) {\n          if (key.match(VAR_NAME_RE)) {\n            if (key !== '$attr') {\n              this.set('variable', key, opt);\n            }\n          } else {\n            this.set(key, opt);\n          }\n        }\n      }\n    }\n    return this;\n  }\n  fromTransformation(other) {\n    if (other instanceof TransformationBase) {\n      other.keys().forEach(key => this.set(key, other.get(key).origValue));\n    }\n    return this;\n  }\n  /**\n   * Set a parameter.\n   * The parameter name `key` is converted to\n   * @param {string} key - the name of the parameter\n   * @param {*} values - the value of the parameter\n   * @returns {Transformation} Returns this instance for chaining\n   */\n  set(key) {\n    let camelKey;\n    camelKey = camelCase(key);\n    for (var _len2 = arguments.length, values = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      values[_key2 - 1] = arguments[_key2];\n    }\n    if (contains(methods, camelKey)) {\n      // @ts-ignore\n      this[camelKey].apply(this, values);\n    } else {\n      this.otherOptions[key] = values[0];\n    }\n    return this;\n  }\n  hasLayer() {\n    return this.getValue(\"overlay\") || this.getValue(\"underlay\");\n  }\n  /**\n   * Generate a string representation of the transformation.\n   * @function Transformation#serialize\n   * @return {string} Returns the transformation as a string\n   */\n  serialize() {\n    var ifParam, j, len, paramList, ref, ref1, ref2, ref3, ref4, resultArray, t, transformationList, transformationString, transformations, value, variables, vars;\n    resultArray = this.chained.map(tr => tr.serialize());\n    paramList = this.keys();\n    transformations = (ref = this.get(\"transformation\")) != null ? ref.serialize() : void 0;\n    ifParam = (ref1 = this.get(\"if\")) != null ? ref1.serialize() : void 0;\n    variables = processVar((ref2 = this.get(\"variables\")) != null ? ref2.value() : void 0);\n    paramList = difference(paramList, [\"transformation\", \"if\", \"variables\"]);\n    vars = [];\n    transformationList = [];\n    for (j = 0, len = paramList.length; j < len; j++) {\n      t = paramList[j];\n      if (t.match(VAR_NAME_RE)) {\n        vars.push(t + \"_\" + Expression.normalize((ref3 = this.get(t)) != null ? ref3.value() : void 0));\n      } else {\n        transformationList.push((ref4 = this.get(t)) != null ? ref4.serialize() : void 0);\n      }\n    }\n    switch (false) {\n      case !isString(transformations):\n        transformationList.push(transformations);\n        break;\n      case !Array.isArray(transformations):\n        resultArray = resultArray.concat(transformations);\n    }\n    transformationList = function () {\n      var k, len1, results;\n      results = [];\n      for (k = 0, len1 = transformationList.length; k < len1; k++) {\n        value = transformationList[k];\n        if (Array.isArray(value) && !isEmpty(value) || !Array.isArray(value) && value) {\n          results.push(value);\n        }\n      }\n      return results;\n    }();\n    transformationList = vars.sort().concat(variables).concat(transformationList.sort());\n    if (ifParam === \"if_end\") {\n      transformationList.push(ifParam);\n    } else if (!isEmpty(ifParam)) {\n      transformationList.unshift(ifParam);\n    }\n    transformationString = transformationList.filter(x => !!x).join(param_separator);\n    if (!isEmpty(transformationString)) {\n      resultArray.push(transformationString);\n    }\n    return resultArray.filter(x => !!x).join(trans_separator);\n  }\n  /**\n   * Provide a list of all the valid transformation option names\n   * @function Transformation#listNames\n   * @private\n   * @return {Array<string>} a array of all the valid option names\n   */\n  static listNames() {\n    return methods;\n  }\n  /**\n   * Returns the attributes for an HTML tag.\n   * @function Cloudinary.toHtmlAttributes\n   * @return PlainObject\n   */\n  toHtmlAttributes() {\n    let attrName, height, options, ref2, ref3, value, width;\n    options = {};\n    let snakeCaseKey;\n    Object.keys(this.otherOptions).forEach(key => {\n      value = this.otherOptions[key];\n      snakeCaseKey = snakeCase(key);\n      if (!contains(PARAM_NAMES, snakeCaseKey) && !contains(URL_KEYS, snakeCaseKey)) {\n        attrName = /^html_/.test(key) ? key.slice(5) : key;\n        options[attrName] = value;\n      }\n    });\n    // convert all \"html_key\" to \"key\" with the same value\n    this.keys().forEach(key => {\n      if (/^html_/.test(key)) {\n        options[camelCase(key.slice(5))] = this.getValue(key);\n      }\n    });\n    if (!(this.hasLayer() || this.getValue(\"angle\") || contains([\"fit\", \"limit\", \"lfill\"], this.getValue(\"crop\")))) {\n      width = (ref2 = this.get(\"width\")) != null ? ref2.origValue : void 0;\n      height = (ref3 = this.get(\"height\")) != null ? ref3.origValue : void 0;\n      if (parseFloat(width) >= 1.0) {\n        if (options.width == null) {\n          options.width = width;\n        }\n      }\n      if (parseFloat(height) >= 1.0) {\n        if (options.height == null) {\n          options.height = height;\n        }\n      }\n    }\n    return options;\n  }\n  static isValidParamName(name) {\n    return methods.indexOf(camelCase(name)) >= 0;\n  }\n  /**\n   * Delegate to the parent (up the call chain) to produce HTML\n   * @function Transformation#toHtml\n   * @return {string} HTML representation of the parent if possible.\n   * @example\n   * tag = cloudinary.ImageTag.new(\"sample\", {cloud_name: \"demo\"})\n   * // ImageTag {name: \"img\", publicId: \"sample\"}\n   * tag.toHtml()\n   * // <img src=\"http://res.cloudinary.com/demo/image/upload/sample\">\n   * tag.transformation().crop(\"fit\").width(300).toHtml()\n   * // <img src=\"http://res.cloudinary.com/demo/image/upload/c_fit,w_300/sample\">\n   */\n  toHtml() {\n    var ref;\n    return (ref = this.getParent()) != null ? typeof ref.toHtml === \"function\" ? ref.toHtml() : void 0 : void 0;\n  }\n  toString() {\n    return this.serialize();\n  }\n  clone() {\n    return new TransformationBase(this.toOptions(true));\n  }\n}\nconst VAR_NAME_RE = /^\\$[a-zA-Z0-9]+$/;\nconst trans_separator = '/';\nconst param_separator = ',';\nfunction lastArgCallback(args) {\n  var callback;\n  callback = args != null ? args[args.length - 1] : void 0;\n  if (isFunction(callback)) {\n    return callback;\n  } else {\n    return void 0;\n  }\n}\nfunction processVar(varArray) {\n  var j, len, name, results, v;\n  if (Array.isArray(varArray)) {\n    results = [];\n    for (j = 0, len = varArray.length; j < len; j++) {\n      [name, v] = varArray[j];\n      results.push(`${name}_${Expression.normalize(v)}`);\n    }\n    return results;\n  } else {\n    return varArray;\n  }\n}\n// @ts-ignore\nfunction processCustomFunction(_ref) {\n  let {\n    function_type,\n    source\n  } = _ref;\n  if (function_type === 'remote') {\n    return [function_type, btoa(source)].join(\":\");\n  } else if (function_type === 'wasm') {\n    return [function_type, source].join(\":\");\n  }\n}\n/**\n * Transformation Class methods.\n * This is a list of the parameters defined in Transformation.\n * Values are camelCased.\n * @const Transformation.methods\n * @private\n * @ignore\n * @type {Array<string>}\n */\n/**\n * Parameters that are filtered out before passing the options to an HTML tag.\n *\n * The list of parameters is a combination of `Transformation::methods` and `Configuration::CONFIG_PARAMS`\n * @const {Array<string>} Transformation.PARAM_NAMES\n * @private\n * @ignore\n * @see toHtmlAttributes\n */\nclass Transformation extends TransformationBase {\n  /**\n   * Represents a single transformation.\n   * @class Transformation\n   * @example\n   * t = new cloudinary.Transformation();\n   * t.angle(20).crop(\"scale\").width(\"auto\");\n   *\n   * // or\n   *\n   * t = new cloudinary.Transformation( {angle: 20, crop: \"scale\", width: \"auto\"});\n   * @see <a href=\"https://cloudinary.com/documentation/image_transformation_reference\"\n   *  target=\"_blank\">Available image transformations</a>\n   * @see <a href=\"https://cloudinary.com/documentation/video_transformation_reference\"\n   *  target=\"_blank\">Available video transformations</a>\n   */\n  constructor(options) {\n    super(options);\n  }\n  /**\n   * Convenience constructor\n   * @param {Object} options\n   * @return {Transformation}\n   * @example cl = cloudinary.Transformation.new( {angle: 20, crop: \"scale\", width: \"auto\"})\n   */\n  static new(options) {\n    return new Transformation(options);\n  }\n  /*\n    Transformation Parameters\n  */\n  angle(value) {\n    this.arrayParam(value, \"angle\", \"a\", \".\", Expression.normalize);\n    return this;\n  }\n  audioCodec(value) {\n    this.param(value, \"audio_codec\", \"ac\");\n    return this;\n  }\n  audioFrequency(value) {\n    this.param(value, \"audio_frequency\", \"af\");\n    return this;\n  }\n  aspectRatio(value) {\n    this.param(value, \"aspect_ratio\", \"ar\", Expression.normalize);\n    return this;\n  }\n  background(value) {\n    this.param(value, \"background\", \"b\", Param.norm_color);\n    return this;\n  }\n  bitRate(value) {\n    this.param(value, \"bit_rate\", \"br\");\n    return this;\n  }\n  border(value) {\n    return this.param(value, \"border\", \"bo\", border => {\n      if (isObject(border)) {\n        border = Object.assign({}, {\n          color: \"black\",\n          width: 2\n        }, border);\n        return `${border.width}px_solid_${Param.norm_color(border.color)}`;\n      } else {\n        return border;\n      }\n    });\n  }\n  color(value) {\n    this.param(value, \"color\", \"co\", Param.norm_color);\n    return this;\n  }\n  colorSpace(value) {\n    this.param(value, \"color_space\", \"cs\");\n    return this;\n  }\n  crop(value) {\n    this.param(value, \"crop\", \"c\");\n    return this;\n  }\n  customFunction(value) {\n    return this.param(value, \"custom_function\", \"fn\", () => {\n      return processCustomFunction(value);\n    });\n  }\n  customPreFunction(value) {\n    if (this.get('custom_function')) {\n      return;\n    }\n    return this.rawParam(value, \"custom_function\", \"\", () => {\n      value = processCustomFunction(value);\n      return value ? `fn_pre:${value}` : value;\n    });\n  }\n  defaultImage(value) {\n    this.param(value, \"default_image\", \"d\");\n    return this;\n  }\n  delay(value) {\n    this.param(value, \"delay\", \"dl\");\n    return this;\n  }\n  density(value) {\n    this.param(value, \"density\", \"dn\");\n    return this;\n  }\n  duration(value) {\n    this.rangeParam(value, \"duration\", \"du\");\n    return this;\n  }\n  dpr(value) {\n    return this.param(value, \"dpr\", \"dpr\", dpr => {\n      dpr = dpr.toString();\n      if (dpr != null ? dpr.match(/^\\d+$/) : void 0) {\n        return dpr + \".0\";\n      } else {\n        return Expression.normalize(dpr);\n      }\n    });\n  }\n  effect(value) {\n    this.arrayParam(value, \"effect\", \"e\", \":\", Expression.normalize);\n    return this;\n  }\n  else() {\n    return this.if('else');\n  }\n  endIf() {\n    return this.if('end');\n  }\n  endOffset(value) {\n    this.rangeParam(value, \"end_offset\", \"eo\");\n    return this;\n  }\n  fallbackContent(value) {\n    this.param(value, \"fallback_content\");\n    return this;\n  }\n  fetchFormat(value) {\n    this.param(value, \"fetch_format\", \"f\");\n    return this;\n  }\n  format(value) {\n    this.param(value, \"format\");\n    return this;\n  }\n  flags(value) {\n    this.arrayParam(value, \"flags\", \"fl\", \".\");\n    return this;\n  }\n  gravity(value) {\n    this.param(value, \"gravity\", \"g\");\n    return this;\n  }\n  fps(value) {\n    return this.param(value, \"fps\", \"fps\", fps => {\n      if (isString(fps)) {\n        return fps;\n      } else if (Array.isArray(fps)) {\n        return fps.join(\"-\");\n      } else {\n        return fps;\n      }\n    });\n  }\n  height(value) {\n    return this.param(value, \"height\", \"h\", () => {\n      if (this.getValue(\"crop\") || this.getValue(\"overlay\") || this.getValue(\"underlay\")) {\n        return Expression.normalize(value);\n      } else {\n        return null;\n      }\n    });\n  }\n  htmlHeight(value) {\n    this.param(value, \"html_height\");\n    return this;\n  }\n  htmlWidth(value) {\n    this.param(value, \"html_width\");\n    return this;\n  }\n  if() {\n    let value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"\";\n    var i, ifVal, j, ref, trIf, trRest;\n    switch (value) {\n      case \"else\":\n        this.chain();\n        return this.param(value, \"if\", \"if\");\n      case \"end\":\n        this.chain();\n        for (i = j = ref = this.chained.length - 1; j >= 0; i = j += -1) {\n          ifVal = this.chained[i].getValue(\"if\");\n          if (ifVal === \"end\") {\n            break;\n          } else if (ifVal != null) {\n            trIf = Transformation.new().if(ifVal);\n            this.chained[i].remove(\"if\");\n            trRest = this.chained[i];\n            this.chained[i] = Transformation.new().transformation([trIf, trRest]);\n            if (ifVal !== \"else\") {\n              break;\n            }\n          }\n        }\n        return this.param(value, \"if\", \"if\");\n      case \"\":\n        return Condition.new().setParent(this);\n      default:\n        return this.param(value, \"if\", \"if\", value => {\n          return Condition.new(value).toString();\n        });\n    }\n  }\n  keyframeInterval(value) {\n    this.param(value, \"keyframe_interval\", \"ki\");\n    return this;\n  }\n  ocr(value) {\n    this.param(value, \"ocr\", \"ocr\");\n    return this;\n  }\n  offset(value) {\n    var end_o, start_o;\n    [start_o, end_o] = isFunction(value != null ? value.split : void 0) ? value.split('..') : Array.isArray(value) ? value : [null, null];\n    if (start_o != null) {\n      this.startOffset(start_o);\n    }\n    if (end_o != null) {\n      return this.endOffset(end_o);\n    }\n  }\n  opacity(value) {\n    this.param(value, \"opacity\", \"o\", Expression.normalize);\n    return this;\n  }\n  overlay(value) {\n    this.layerParam(value, \"overlay\", \"l\");\n    return this;\n  }\n  page(value) {\n    this.param(value, \"page\", \"pg\");\n    return this;\n  }\n  poster(value) {\n    this.param(value, \"poster\");\n    return this;\n  }\n  prefix(value) {\n    this.param(value, \"prefix\", \"p\");\n    return this;\n  }\n  quality(value) {\n    this.param(value, \"quality\", \"q\", Expression.normalize);\n    return this;\n  }\n  radius(value) {\n    this.arrayParam(value, \"radius\", \"r\", \":\", Expression.normalize);\n    return this;\n  }\n  rawTransformation(value) {\n    this.rawParam(value, \"raw_transformation\");\n    return this;\n  }\n  size(value) {\n    let height, width;\n    if (isFunction(value != null ? value.split : void 0)) {\n      [width, height] = value.split('x');\n      this.width(width);\n      return this.height(height);\n    }\n  }\n  sourceTypes(value) {\n    this.param(value, \"source_types\");\n    return this;\n  }\n  sourceTransformation(value) {\n    return this.param(value, \"source_transformation\");\n  }\n  startOffset(value) {\n    this.rangeParam(value, \"start_offset\", \"so\");\n    return this;\n  }\n  streamingProfile(value) {\n    this.param(value, \"streaming_profile\", \"sp\");\n    return this;\n  }\n  transformation(value) {\n    this.transformationParam(value, \"transformation\", \"t\");\n    return this;\n  }\n  underlay(value) {\n    this.layerParam(value, \"underlay\", \"u\");\n    return this;\n  }\n  variable(name, value) {\n    this.param(value, name, name);\n    return this;\n  }\n  variables(values) {\n    this.arrayParam(values, \"variables\");\n    return this;\n  }\n  videoCodec(value) {\n    this.param(value, \"video_codec\", \"vc\", Param.process_video_params);\n    return this;\n  }\n  videoSampling(value) {\n    this.param(value, \"video_sampling\", \"vs\");\n    return this;\n  }\n  width(value) {\n    this.param(value, \"width\", \"w\", () => {\n      if (this.getValue(\"crop\") || this.getValue(\"overlay\") || this.getValue(\"underlay\")) {\n        return Expression.normalize(value);\n      } else {\n        return null;\n      }\n    });\n    return this;\n  }\n  x(value) {\n    this.param(value, \"x\", \"x\", Expression.normalize);\n    return this;\n  }\n  y(value) {\n    this.param(value, \"y\", \"y\", Expression.normalize);\n    return this;\n  }\n  zoom(value) {\n    this.param(value, \"zoom\", \"z\", Expression.normalize);\n    return this;\n  }\n}\n/**\n * Transformation Class methods.\n * This is a list of the parameters defined in Transformation.\n * Values are camelCased.\n */\nconst methods = [\"angle\", \"audioCodec\", \"audioFrequency\", \"aspectRatio\", \"background\", \"bitRate\", \"border\", \"color\", \"colorSpace\", \"crop\", \"customFunction\", \"customPreFunction\", \"defaultImage\", \"delay\", \"density\", \"duration\", \"dpr\", \"effect\", \"else\", \"endIf\", \"endOffset\", \"fallbackContent\", \"fetchFormat\", \"format\", \"flags\", \"gravity\", \"fps\", \"height\", \"htmlHeight\", \"htmlWidth\", \"if\", \"keyframeInterval\", \"ocr\", \"offset\", \"opacity\", \"overlay\", \"page\", \"poster\", \"prefix\", \"quality\", \"radius\", \"rawTransformation\", \"size\", \"sourceTypes\", \"sourceTransformation\", \"startOffset\", \"streamingProfile\", \"transformation\", \"underlay\", \"variable\", \"variables\", \"videoCodec\", \"videoSampling\", \"width\", \"x\", \"y\", \"zoom\"];\n/**\n * Parameters that are filtered out before passing the options to an HTML tag.\n *\n * The list of parameters is a combination of `Transformation::methods` and `Configuration::CONFIG_PARAMS`\n */\nconst PARAM_NAMES = methods.map(snakeCase).concat(CONFIG_PARAMS);\nexport default Transformation;","map":{"version":3,"names":["Condition","CONFIG_PARAMS","cloneDeep","camelCase","contains","difference","snakeCase","Expression","Layer","TextLayer","SubtitlesLayer","FetchLayer","isObject","isString","isEmpty","isFunction","identity","withCamelCaseKeys","URL_KEYS","assignNotNull","target","_len","arguments","length","sources","Array","_key","forEach","source","Object","keys","key","allStrings","list","every","Param","constructor","name","shortName","process","undefined","set","origValue","serialize","val","valid","value","isArray","norm_color","replace","build_array","arg","process_video_params","param","video","codec","profile","level","String","ArrayParam","sep","arrayValue","flat","map","t","join","v","TransformationParam","result","joined","Transformation","filter","origValue1","number_pattern","offset_any_pattern","RangeParam","norm_range_value","offset","match","RegExp","modifier","RawParam","LayerParam","layerOptions","resourceType","text","url","test","substr","toString","textStyle","layer","textStyleIdentifier","TransformationBase","options","parent","trans","toOptions","withChain","opt","otherOptions","chained","tr","push","transformation","setParent","object","fromOptions","getParent","abbr","defaultValue","rawParam","lastArgCallback","rangeParam","arrayParam","transformationParam","layerParam","getValue","get","remove","temp","results","VAR_NAME_RE","sort","toPlainObject","hash","chain","names","getOwnPropertyNames","resetTransformations","fromTransformation","other","camelKey","_len2","values","_key2","methods","apply","hasLayer","ifParam","j","len","paramList","ref","ref1","ref2","ref3","ref4","resultArray","transformationList","transformationString","transformations","variables","vars","processVar","normalize","concat","k","len1","unshift","x","param_separator","trans_separator","listNames","toHtmlAttributes","attrName","height","width","snakeCaseKey","PARAM_NAMES","slice","parseFloat","isValidParamName","indexOf","toHtml","clone","args","callback","varArray","processCustomFunction","_ref","function_type","btoa","new","angle","audioCodec","audioFrequency","aspectRatio","background","bitRate","border","assign","color","colorSpace","crop","customFunction","customPreFunction","defaultImage","delay","density","duration","dpr","effect","else","if","endIf","endOffset","fallbackContent","fetchFormat","format","flags","gravity","fps","htmlHeight","htmlWidth","i","ifVal","trIf","trRest","keyframeInterval","ocr","end_o","start_o","split","startOffset","opacity","overlay","page","poster","prefix","quality","radius","rawTransformation","size","sourceTypes","sourceTransformation","streamingProfile","underlay","variable","videoCodec","videoSampling","y","zoom"],"sources":["/Users/tomasferrari/Documentos/Code/WineMe/wineme/node_modules/@cloudinary/url-gen/backwards/transformation.js"],"sourcesContent":["import Condition from './condition.js';\nimport { CONFIG_PARAMS } from './configuration.js';\nimport { cloneDeep } from '../internal/utils/cloneDeep.js';\nimport { camelCase, contains, difference, } from \"./utils/legacyBaseUtil.js\";\nimport { snakeCase } from \"./utils/snakeCase.js\";\nimport Expression from './expression.js';\nimport Layer from './legacyLayer/layer.js';\nimport TextLayer from './legacyLayer/textlayer.js';\nimport SubtitlesLayer from './legacyLayer/subtitleslayer.js';\nimport FetchLayer from './legacyLayer/fetchlayer.js';\nimport { isObject } from \"./utils/isObject.js\";\nimport { isString } from \"../internal/utils/dataStructureUtils.js\";\nimport { isEmpty } from \"./utils/isEmpty.js\";\nimport { isFunction } from \"./utils/isFunction.js\";\nimport { identity, withCamelCaseKeys } from \"./utils/legacyBaseUtil.js\";\n/**\n * A list of keys used by the url() function.\n * @private\n */\nexport const URL_KEYS = [\n    'accessibility',\n    'api_secret',\n    'auth_token',\n    'cdn_subdomain',\n    'cloud_name',\n    'cname',\n    'format',\n    'placeholder',\n    'private_cdn',\n    'resource_type',\n    'secure',\n    'secure_cdn_subdomain',\n    'secure_distribution',\n    'shorten',\n    'sign_url',\n    'signature',\n    'ssl_detected',\n    'type',\n    'url_suffix',\n    'use_root_path',\n    'version'\n];\n/**\n * Assign key, value to target, when value is not null.<br>\n *   This function mutates the target!\n * @param {object} target the object to assign the values to\n * @param {object} sources one or more objects to get values from\n * @returns {object} the target after the assignment\n */\nfunction assignNotNull(target, ...sources) {\n    sources.forEach(source => {\n        Object.keys(source).forEach(key => {\n            // @ts-ignore\n            if (source[key] != null) {\n                // @ts-ignore\n                target[key] = source[key];\n            }\n        });\n    });\n    return target;\n}\n/**\n * Return true if all items in list are strings\n * @function Util.allString\n * @param {Array} list - an array of items\n */\nconst allStrings = function (list) {\n    return list.length && list.every(isString);\n};\n/**\n * Transformation parameters\n * Depends on 'util', 'transformation'\n */\nclass Param {\n    /**\n     * Represents a single parameter.\n     * @class Param\n     * @param {string} name - The name of the parameter in snake_case\n     * @param {string} shortName - The name of the serialized form of the parameter.\n     *                         If a value is not provided, the parameter will not be serialized.\n     * @param {function} [process=Util.identity ] - Manipulate origValue when value is called\n     * @ignore\n     */\n    constructor(name, shortName, process = identity) {\n        /**\n         * The name of the parameter in snake_case\n         * @member {string} Param#name\n         */\n        this.name = name;\n        /**\n         * The name of the serialized form of the parameter\n         * @member {string} Param#shortName\n         */\n        this.shortName = shortName;\n        /**\n         * Manipulate origValue when value is called\n         * @member {function} Param#process\n         */\n        this.process = process;\n    }\n    /**\n     * Set a (unprocessed) value for this parameter\n     * @function Param#set\n     * @param {*} origValue - the value of the parameter\n     * @return {Param} self for chaining\n     */\n    set(origValue) {\n        this.origValue = origValue;\n        return this;\n    }\n    /**\n     * Generate the serialized form of the parameter\n     * @function Param#serialize\n     * @return {string} the serialized form of the parameter\n     */\n    serialize() {\n        var val, valid;\n        val = this.value();\n        valid = Array.isArray(val) || isObject(val) || isString(val) ? !isEmpty(val) : val != null;\n        if ((this.shortName != null) && valid) {\n            return `${this.shortName}_${val}`;\n        }\n        else {\n            return '';\n        }\n    }\n    /**\n     * Return the processed value of the parameter\n     * @function Param#value\n     */\n    value() {\n        return this.process(this.origValue);\n    }\n    static norm_color(value) {\n        return value != null ? value.replace(/^#/, 'rgb:') : void 0;\n    }\n    static build_array(arg) {\n        if (arg == null) {\n            return [];\n        }\n        else if (Array.isArray(arg)) {\n            return arg;\n        }\n        else {\n            return [arg];\n        }\n    }\n    /**\n     * Covert value to video codec string.\n     *\n     * If the parameter is an object,\n     * @param {(string|Object)} param - the video codec as either a String or a Hash\n     * @return {string} the video codec string in the format codec:profile:level\n     * @example\n     * vc_[ :profile : [level]]\n     * or\n     { codec: 'h264', profile: 'basic', level: '3.1' }\n     * @ignore\n     */\n    static process_video_params(param) {\n        var video;\n        switch (param.constructor) {\n            case Object:\n                video = \"\";\n                if ('codec' in param) {\n                    video = param.codec;\n                    if ('profile' in param) {\n                        video += \":\" + param.profile;\n                        if ('level' in param) {\n                            video += \":\" + param.level;\n                        }\n                    }\n                }\n                return video;\n            case String:\n                return param;\n            default:\n                return null;\n        }\n    }\n}\nclass ArrayParam extends Param {\n    /**\n     * A parameter that represents an array.\n     * @param {string} name - The name of the parameter in snake_case.\n     * @param {string} shortName - The name of the serialized form of the parameter\n     *                         If a value is not provided, the parameter will not be serialized.\n     * @param {string} [sep='.'] - The separator to use when joining the array elements together\n     * @param {function} [process=Util.identity ] - Manipulate origValue when value is called\n     * @class ArrayParam\n     * @extends Param\n     * @ignore\n     */\n    constructor(name, shortName, sep = '.', process = undefined) {\n        super(name, shortName, process);\n        this.sep = sep;\n    }\n    serialize() {\n        if (this.shortName != null) {\n            let arrayValue = this.value();\n            if (isEmpty(arrayValue)) {\n                return '';\n            }\n            else if (isString(arrayValue)) {\n                return `${this.shortName}_${arrayValue}`;\n            }\n            else {\n                let flat = arrayValue.map((t) => isFunction(t.serialize) ? t.serialize() : t).join(this.sep);\n                return `${this.shortName}_${flat}`;\n            }\n        }\n        else {\n            return '';\n        }\n    }\n    value() {\n        if (Array.isArray(this.origValue)) {\n            return this.origValue.map(v => this.process(v));\n        }\n        else {\n            return this.process(this.origValue);\n        }\n    }\n    set(origValue) {\n        if ((origValue == null) || Array.isArray(origValue)) {\n            return super.set(origValue);\n        }\n        else {\n            return super.set([origValue]);\n        }\n    }\n}\nclass TransformationParam extends Param {\n    /**\n     * A parameter that represents a transformation\n     * @param {string} name - The name of the parameter in snake_case\n     * @param {string} [shortName='t'] - The name of the serialized form of the parameter\n     * @param {string} [sep='.'] - The separator to use when joining the array elements together\n     * @param {function} [process=Util.identity ] - Manipulate origValue when value is called\n     * @class TransformationParam\n     * @extends Param\n     * @ignore\n     */\n    constructor(name, shortName = \"t\", sep = '.', process = undefined) {\n        super(name, shortName, process);\n        this.sep = sep;\n    }\n    /**\n     * Generate string representations of the transformation.\n     * @returns {*} Returns either the transformation as a string, or an array of string representations.\n     */\n    serialize() {\n        let result = '';\n        const val = this.value();\n        if (isEmpty(val)) {\n            return result;\n        }\n        // val is an array of strings so join them\n        if (allStrings(val)) {\n            const joined = val.join(this.sep); // creates t1.t2.t3 in case multiple named transformations were configured\n            if (!isEmpty(joined)) {\n                // in case options.transformation was not set with an empty string (val != ['']);\n                result = `${this.shortName}_${joined}`;\n            }\n        }\n        else { // Convert val to an array of strings\n            result = val.map((t) => {\n                if (isString(t) && !isEmpty(t)) {\n                    return `${this.shortName}_${t}`;\n                }\n                if (isFunction(t.serialize)) {\n                    return t.serialize();\n                }\n                if (isObject(t) && !isEmpty(t)) {\n                    return new Transformation(t).serialize();\n                }\n                return undefined;\n            }).filter((t) => t);\n        }\n        return result;\n    }\n    set(origValue1) {\n        this.origValue = origValue1;\n        if (Array.isArray(this.origValue)) {\n            return super.set(this.origValue);\n        }\n        else {\n            return super.set([this.origValue]);\n        }\n    }\n}\nconst number_pattern = \"([0-9]*)\\\\.([0-9]+)|([0-9]+)\";\nconst offset_any_pattern = \"(\" + number_pattern + \")([%pP])?\";\nclass RangeParam extends Param {\n    /**\n     * A parameter that represents a range\n     * @param {string} name - The name of the parameter in snake_case\n     * @param {string} shortName - The name of the serialized form of the parameter\n     *                         If a value is not provided, the parameter will not be serialized.\n     * @param {function} [process=norm_range_value ] - Manipulate origValue when value is called\n     * @class RangeParam\n     * @extends Param\n     * @ignore\n     */\n    constructor(name, shortName, process = RangeParam.norm_range_value) {\n        super(name, shortName, process);\n    }\n    static norm_range_value(value) {\n        let offset = String(value).match(new RegExp('^' + offset_any_pattern + '$'));\n        if (offset) {\n            let modifier = offset[5] != null ? 'p' : '';\n            value = (offset[1] || offset[4]) + modifier;\n        }\n        return value;\n    }\n}\nclass RawParam extends Param {\n    constructor(name, shortName, process = identity) {\n        super(name, shortName, process);\n    }\n    serialize() {\n        return this.value();\n    }\n}\nclass LayerParam extends Param {\n    // Parse layer options\n    // @return [string] layer transformation string\n    // @private\n    value() {\n        if (this.origValue == null) {\n            return '';\n        }\n        let result;\n        if (this.origValue instanceof Layer) {\n            result = this.origValue;\n        }\n        else if (isObject(this.origValue)) {\n            let layerOptions = withCamelCaseKeys(this.origValue);\n            // @ts-ignore\n            if (layerOptions.resourceType === \"text\" || (layerOptions.text != null)) {\n                result = new TextLayer(layerOptions);\n            }\n            else { // @ts-ignore\n                if (layerOptions.resourceType === \"subtitles\") {\n                    result = new SubtitlesLayer(layerOptions);\n                }\n                else { // @ts-ignore\n                    if (layerOptions.resourceType === \"fetch\" || (layerOptions.url != null)) {\n                        result = new FetchLayer(layerOptions);\n                    }\n                    else {\n                        result = new Layer(layerOptions);\n                    }\n                }\n            }\n        }\n        else if (isString(this.origValue)) {\n            if (/^fetch:.+/.test(this.origValue)) {\n                result = new FetchLayer(this.origValue.substr(6));\n            }\n            else {\n                result = this.origValue;\n            }\n        }\n        else {\n            result = '';\n        }\n        return result.toString();\n    }\n    static textStyle(layer) {\n        return (new TextLayer(layer)).textStyleIdentifier();\n    }\n}\n/**\n * TransformationBase\n * Depends on 'configuration', 'parameters','util'\n * @internal\n */\nclass TransformationBase {\n    /**\n     * The base class for transformations.\n     * Members of this class are documented as belonging to the {@link Transformation} class for convenience.\n     * @class TransformationBase\n     */\n    constructor(options) {\n        /** @private */\n        /** @private */\n        let parent;\n        let trans;\n        parent = void 0;\n        trans = {};\n        /**\n         * Return an options object that can be used to create an identical Transformation\n         * @function Transformation#toOptions\n         * @return {Object} Returns a plain object representing this transformation\n         */\n        this.toOptions = (withChain) => {\n            let opt = {};\n            if (withChain == null) {\n                withChain = true;\n            }\n            // @ts-ignore\n            Object.keys(trans).forEach(key => opt[key] = trans[key].origValue);\n            assignNotNull(opt, this.otherOptions);\n            if (withChain && !isEmpty(this.chained)) {\n                let list = this.chained.map((tr) => tr.toOptions());\n                list.push(opt);\n                opt = {};\n                assignNotNull(opt, this.otherOptions);\n                // @ts-ignore\n                opt.transformation = list;\n            }\n            return opt;\n        };\n        /**\n         * Set a parent for this object for chaining purposes.\n         *\n         * @function Transformation#setParent\n         * @param {Object} object - the parent to be assigned to\n         * @returns {Transformation} Returns this instance for chaining purposes.\n         */\n        this.setParent = (object) => {\n            parent = object;\n            if (object != null) {\n                // @ts-ignore\n                this.fromOptions(typeof object.toOptions === \"function\" ? object.toOptions() : void 0);\n            }\n            return this;\n        };\n        /**\n         * Returns the parent of this object in the chain\n         * @function Transformation#getParent\n         * @protected\n         * @return {Object} Returns the parent of this object if there is any\n         */\n        this.getParent = () => {\n            return parent;\n        };\n        // Helper methods to create parameter methods\n        // These methods are defined here because they access `trans` which is\n        // a private member of `TransformationBase`\n        /** @protected */\n        this.param = (value, name, abbr, defaultValue, process) => {\n            if (process == null) {\n                if (isFunction(defaultValue)) {\n                    process = defaultValue;\n                }\n                else {\n                    process = identity;\n                }\n            }\n            // @ts-ignore\n            trans[name] = new Param(name, abbr, process).set(value);\n            return this;\n        };\n        /** @protected */\n        this.rawParam = function (value, name, abbr, defaultValue, process) {\n            process = lastArgCallback(arguments);\n            // @ts-ignore\n            trans[name] = new RawParam(name, abbr, process).set(value);\n            return this;\n        };\n        /** @protected */\n        this.rangeParam = function (value, name, abbr, defaultValue, process) {\n            process = lastArgCallback(arguments);\n            // @ts-ignore\n            trans[name] = new RangeParam(name, abbr, process).set(value);\n            return this;\n        };\n        /** @protected */\n        this.arrayParam = function (value, name, abbr, sep = \":\", defaultValue = [], process = undefined) {\n            process = lastArgCallback(arguments);\n            // @ts-ignore\n            trans[name] = new ArrayParam(name, abbr, sep, process).set(value);\n            return this;\n        };\n        /** @protected */\n        this.transformationParam = function (value, name, abbr, sep = \".\", defaultValue = undefined, process = undefined) {\n            process = lastArgCallback(arguments);\n            // @ts-ignore\n            trans[name] = new TransformationParam(name, abbr, sep, process).set(value);\n            return this;\n        };\n        this.layerParam = function (value, name, abbr) {\n            // @ts-ignore\n            trans[name] = new LayerParam(name, abbr).set(value);\n            return this;\n        };\n        // End Helper methods\n        /**\n         * Get the value associated with the given name.\n         * Get the value associated with the given name.\n         * @function Transformation#getValue\n         * @param {string} name - the name of the parameter\n         * @return {*} the processed value associated with the given name\n         * @description Use {@link get}.origValue for the value originally provided for the parameter\n         */\n        this.getValue = function (name) {\n            // @ts-ignore\n            let value = trans[name] && trans[name].value();\n            return value != null ? value : this.otherOptions[name];\n        };\n        /**\n         * Get the parameter object for the given parameter name\n         * @function Transformation#get\n         * @param {string} name the name of the transformation parameter\n         * @returns {Param} the param object for the given name, or undefined\n         */\n        this.get = function (name) {\n            // @ts-ignore\n            return trans[name];\n        };\n        /**\n         * Remove a transformation option from the transformation.\n         * @function Transformation#remove\n         * @param {string} name - the name of the option to remove\n         * @return {*} Returns the option that was removed or null if no option by that name was found. The type of the\n         *              returned value depends on the value.\n         */\n        this.remove = function (name) {\n            var temp;\n            switch (false) {\n                // @ts-ignore\n                case trans[name] == null:\n                    // @ts-ignore\n                    temp = trans[name];\n                    // @ts-ignore\n                    delete trans[name];\n                    return temp.origValue;\n                case this.otherOptions[name] == null:\n                    temp = this.otherOptions[name];\n                    delete this.otherOptions[name];\n                    return temp;\n                default:\n                    return null;\n            }\n        };\n        /**\n         * Return an array of all the keys (option names) in the transformation.\n         * @return {Array<string>} the keys in snakeCase format\n         */\n        this.keys = function () {\n            var key;\n            return ((function () {\n                var results;\n                results = [];\n                for (key in trans) {\n                    if (key != null) {\n                        results.push(key.match(VAR_NAME_RE) ? key : snakeCase(key));\n                    }\n                }\n                return results;\n            })()).sort();\n        };\n        /**\n         * Returns a plain object representation of the transformation. Values are processed.\n         * @function Transformation#toPlainObject\n         * @return {Object} the transformation options as plain object\n         */\n        this.toPlainObject = function () {\n            var hash, key, list;\n            hash = {};\n            for (key in trans) {\n                // @ts-ignore\n                hash[key] = trans[key].value();\n                // @ts-ignore\n                if (isObject(hash[key])) {\n                    // @ts-ignore\n                    hash[key] = cloneDeep(hash[key]);\n                }\n            }\n            if (!isEmpty(this.chained)) {\n                list = this.chained.map((tr) => tr.toPlainObject());\n                list.push(hash);\n                hash = {\n                    transformation: list\n                };\n            }\n            return hash;\n        };\n        /**\n         * Complete the current transformation and chain to a new one.\n         * In the URL, transformations are chained together by slashes.\n         * @function Transformation#chain\n         * @return {Transformation} Returns this transformation for chaining\n         * @example\n         * var tr = cloudinary.Transformation.new();\n         * tr.width(10).crop('fit').chain().angle(15).serialize()\n         * // produces \"c_fit,w_10/a_15\"\n         */\n        this.chain = function () {\n            var names, tr;\n            names = Object.getOwnPropertyNames(trans);\n            if (names.length !== 0) {\n                tr = new this.constructor(this.toOptions(false));\n                this.resetTransformations();\n                this.chained.push(tr);\n            }\n            return this;\n        };\n        this.resetTransformations = function () {\n            trans = {};\n            return this;\n        };\n        this.otherOptions = {};\n        this.chained = [];\n        this.fromOptions(options);\n    }\n    /**\n     * Merge the provided options with own's options\n     * @param {Object} [options={}] key-value list of options\n     * @returns {Transformation} Returns this instance for chaining\n     */\n    fromOptions(options = {}) {\n        if (options instanceof TransformationBase) {\n            this.fromTransformation(options);\n        }\n        else {\n            if (isString(options) || Array.isArray(options)) {\n                options = {\n                    transformation: options\n                };\n            }\n            options = cloneDeep(options);\n            // Handling of \"if\" statements precedes other options as it creates a chained transformation\n            // @ts-ignore\n            if (options[\"if\"]) {\n                // @ts-ignore\n                this.set(\"if\", options[\"if\"]);\n                // @ts-ignore\n                delete options[\"if\"];\n            }\n            for (let key in options) {\n                // @ts-ignore\n                let opt = options[key];\n                if (opt != null) {\n                    if (key.match(VAR_NAME_RE)) {\n                        if (key !== '$attr') {\n                            this.set('variable', key, opt);\n                        }\n                    }\n                    else {\n                        this.set(key, opt);\n                    }\n                }\n            }\n        }\n        return this;\n    }\n    fromTransformation(other) {\n        if (other instanceof TransformationBase) {\n            other.keys().forEach(key => this.set(key, other.get(key).origValue));\n        }\n        return this;\n    }\n    /**\n     * Set a parameter.\n     * The parameter name `key` is converted to\n     * @param {string} key - the name of the parameter\n     * @param {*} values - the value of the parameter\n     * @returns {Transformation} Returns this instance for chaining\n     */\n    set(key, ...values) {\n        let camelKey;\n        camelKey = camelCase(key);\n        if (contains(methods, camelKey)) {\n            // @ts-ignore\n            this[camelKey].apply(this, values);\n        }\n        else {\n            this.otherOptions[key] = values[0];\n        }\n        return this;\n    }\n    hasLayer() {\n        return this.getValue(\"overlay\") || this.getValue(\"underlay\");\n    }\n    /**\n     * Generate a string representation of the transformation.\n     * @function Transformation#serialize\n     * @return {string} Returns the transformation as a string\n     */\n    serialize() {\n        var ifParam, j, len, paramList, ref, ref1, ref2, ref3, ref4, resultArray, t, transformationList, transformationString, transformations, value, variables, vars;\n        resultArray = this.chained.map((tr) => tr.serialize());\n        paramList = this.keys();\n        transformations = (ref = this.get(\"transformation\")) != null ? ref.serialize() : void 0;\n        ifParam = (ref1 = this.get(\"if\")) != null ? ref1.serialize() : void 0;\n        variables = processVar((ref2 = this.get(\"variables\")) != null ? ref2.value() : void 0);\n        paramList = difference(paramList, [\"transformation\", \"if\", \"variables\"]);\n        vars = [];\n        transformationList = [];\n        for (j = 0, len = paramList.length; j < len; j++) {\n            t = paramList[j];\n            if (t.match(VAR_NAME_RE)) {\n                vars.push(t + \"_\" + Expression.normalize((ref3 = this.get(t)) != null ? ref3.value() : void 0));\n            }\n            else {\n                transformationList.push((ref4 = this.get(t)) != null ? ref4.serialize() : void 0);\n            }\n        }\n        switch (false) {\n            case !isString(transformations):\n                transformationList.push(transformations);\n                break;\n            case !Array.isArray(transformations):\n                resultArray = resultArray.concat(transformations);\n        }\n        transformationList = (function () {\n            var k, len1, results;\n            results = [];\n            for (k = 0, len1 = transformationList.length; k < len1; k++) {\n                value = transformationList[k];\n                if (Array.isArray(value) && !isEmpty(value) || !Array.isArray(value) && value) {\n                    results.push(value);\n                }\n            }\n            return results;\n        })();\n        transformationList = vars.sort().concat(variables).concat(transformationList.sort());\n        if (ifParam === \"if_end\") {\n            transformationList.push(ifParam);\n        }\n        else if (!isEmpty(ifParam)) {\n            transformationList.unshift(ifParam);\n        }\n        transformationString = (transformationList).filter(x => !!x).join(param_separator);\n        if (!isEmpty(transformationString)) {\n            resultArray.push(transformationString);\n        }\n        return (resultArray).filter((x) => !!x).join(trans_separator);\n    }\n    /**\n     * Provide a list of all the valid transformation option names\n     * @function Transformation#listNames\n     * @private\n     * @return {Array<string>} a array of all the valid option names\n     */\n    static listNames() {\n        return methods;\n    }\n    /**\n     * Returns the attributes for an HTML tag.\n     * @function Cloudinary.toHtmlAttributes\n     * @return PlainObject\n     */\n    toHtmlAttributes() {\n        let attrName, height, options, ref2, ref3, value, width;\n        options = {};\n        let snakeCaseKey;\n        Object.keys(this.otherOptions).forEach(key => {\n            value = this.otherOptions[key];\n            snakeCaseKey = snakeCase(key);\n            if (!contains(PARAM_NAMES, snakeCaseKey) && !contains(URL_KEYS, snakeCaseKey)) {\n                attrName = /^html_/.test(key) ? key.slice(5) : key;\n                options[attrName] = value;\n            }\n        });\n        // convert all \"html_key\" to \"key\" with the same value\n        this.keys().forEach(key => {\n            if (/^html_/.test(key)) {\n                options[camelCase(key.slice(5))] = this.getValue(key);\n            }\n        });\n        if (!(this.hasLayer() || this.getValue(\"angle\") || contains([\"fit\", \"limit\", \"lfill\"], this.getValue(\"crop\")))) {\n            width = (ref2 = this.get(\"width\")) != null ? ref2.origValue : void 0;\n            height = (ref3 = this.get(\"height\")) != null ? ref3.origValue : void 0;\n            if (parseFloat(width) >= 1.0) {\n                if (options.width == null) {\n                    options.width = width;\n                }\n            }\n            if (parseFloat(height) >= 1.0) {\n                if (options.height == null) {\n                    options.height = height;\n                }\n            }\n        }\n        return options;\n    }\n    static isValidParamName(name) {\n        return methods.indexOf(camelCase(name)) >= 0;\n    }\n    /**\n     * Delegate to the parent (up the call chain) to produce HTML\n     * @function Transformation#toHtml\n     * @return {string} HTML representation of the parent if possible.\n     * @example\n     * tag = cloudinary.ImageTag.new(\"sample\", {cloud_name: \"demo\"})\n     * // ImageTag {name: \"img\", publicId: \"sample\"}\n     * tag.toHtml()\n     * // <img src=\"http://res.cloudinary.com/demo/image/upload/sample\">\n     * tag.transformation().crop(\"fit\").width(300).toHtml()\n     * // <img src=\"http://res.cloudinary.com/demo/image/upload/c_fit,w_300/sample\">\n     */\n    toHtml() {\n        var ref;\n        return (ref = this.getParent()) != null ? typeof ref.toHtml === \"function\" ? ref.toHtml() : void 0 : void 0;\n    }\n    toString() {\n        return this.serialize();\n    }\n    clone() {\n        return new TransformationBase(this.toOptions(true));\n    }\n}\nconst VAR_NAME_RE = /^\\$[a-zA-Z0-9]+$/;\nconst trans_separator = '/';\nconst param_separator = ',';\nfunction lastArgCallback(args) {\n    var callback;\n    callback = args != null ? args[args.length - 1] : void 0;\n    if (isFunction(callback)) {\n        return callback;\n    }\n    else {\n        return void 0;\n    }\n}\nfunction processVar(varArray) {\n    var j, len, name, results, v;\n    if (Array.isArray(varArray)) {\n        results = [];\n        for (j = 0, len = varArray.length; j < len; j++) {\n            [name, v] = varArray[j];\n            results.push(`${name}_${Expression.normalize(v)}`);\n        }\n        return results;\n    }\n    else {\n        return varArray;\n    }\n}\n// @ts-ignore\nfunction processCustomFunction({ function_type, source }) {\n    if (function_type === 'remote') {\n        return [function_type, btoa(source)].join(\":\");\n    }\n    else if (function_type === 'wasm') {\n        return [function_type, source].join(\":\");\n    }\n}\n/**\n * Transformation Class methods.\n * This is a list of the parameters defined in Transformation.\n * Values are camelCased.\n * @const Transformation.methods\n * @private\n * @ignore\n * @type {Array<string>}\n */\n/**\n * Parameters that are filtered out before passing the options to an HTML tag.\n *\n * The list of parameters is a combination of `Transformation::methods` and `Configuration::CONFIG_PARAMS`\n * @const {Array<string>} Transformation.PARAM_NAMES\n * @private\n * @ignore\n * @see toHtmlAttributes\n */\nclass Transformation extends TransformationBase {\n    /**\n     * Represents a single transformation.\n     * @class Transformation\n     * @example\n     * t = new cloudinary.Transformation();\n     * t.angle(20).crop(\"scale\").width(\"auto\");\n     *\n     * // or\n     *\n     * t = new cloudinary.Transformation( {angle: 20, crop: \"scale\", width: \"auto\"});\n     * @see <a href=\"https://cloudinary.com/documentation/image_transformation_reference\"\n     *  target=\"_blank\">Available image transformations</a>\n     * @see <a href=\"https://cloudinary.com/documentation/video_transformation_reference\"\n     *  target=\"_blank\">Available video transformations</a>\n     */\n    constructor(options) {\n        super(options);\n    }\n    /**\n     * Convenience constructor\n     * @param {Object} options\n     * @return {Transformation}\n     * @example cl = cloudinary.Transformation.new( {angle: 20, crop: \"scale\", width: \"auto\"})\n     */\n    static new(options) {\n        return new Transformation(options);\n    }\n    /*\n      Transformation Parameters\n    */\n    angle(value) {\n        this.arrayParam(value, \"angle\", \"a\", \".\", Expression.normalize);\n        return this;\n    }\n    audioCodec(value) {\n        this.param(value, \"audio_codec\", \"ac\");\n        return this;\n    }\n    audioFrequency(value) {\n        this.param(value, \"audio_frequency\", \"af\");\n        return this;\n    }\n    aspectRatio(value) {\n        this.param(value, \"aspect_ratio\", \"ar\", Expression.normalize);\n        return this;\n    }\n    background(value) {\n        this.param(value, \"background\", \"b\", Param.norm_color);\n        return this;\n    }\n    bitRate(value) {\n        this.param(value, \"bit_rate\", \"br\");\n        return this;\n    }\n    border(value) {\n        return this.param(value, \"border\", \"bo\", (border) => {\n            if (isObject(border)) {\n                border = Object.assign({}, {\n                    color: \"black\",\n                    width: 2\n                }, border);\n                return `${border.width}px_solid_${Param.norm_color(border.color)}`;\n            }\n            else {\n                return border;\n            }\n        });\n    }\n    color(value) {\n        this.param(value, \"color\", \"co\", Param.norm_color);\n        return this;\n    }\n    colorSpace(value) {\n        this.param(value, \"color_space\", \"cs\");\n        return this;\n    }\n    crop(value) {\n        this.param(value, \"crop\", \"c\");\n        return this;\n    }\n    customFunction(value) {\n        return this.param(value, \"custom_function\", \"fn\", () => {\n            return processCustomFunction(value);\n        });\n    }\n    customPreFunction(value) {\n        if (this.get('custom_function')) {\n            return;\n        }\n        return this.rawParam(value, \"custom_function\", \"\", () => {\n            value = processCustomFunction(value);\n            return value ? `fn_pre:${value}` : value;\n        });\n    }\n    defaultImage(value) {\n        this.param(value, \"default_image\", \"d\");\n        return this;\n    }\n    delay(value) {\n        this.param(value, \"delay\", \"dl\");\n        return this;\n    }\n    density(value) {\n        this.param(value, \"density\", \"dn\");\n        return this;\n    }\n    duration(value) {\n        this.rangeParam(value, \"duration\", \"du\");\n        return this;\n    }\n    dpr(value) {\n        return this.param(value, \"dpr\", \"dpr\", (dpr) => {\n            dpr = dpr.toString();\n            if (dpr != null ? dpr.match(/^\\d+$/) : void 0) {\n                return dpr + \".0\";\n            }\n            else {\n                return Expression.normalize(dpr);\n            }\n        });\n    }\n    effect(value) {\n        this.arrayParam(value, \"effect\", \"e\", \":\", Expression.normalize);\n        return this;\n    }\n    else() {\n        return this.if('else');\n    }\n    endIf() {\n        return this.if('end');\n    }\n    endOffset(value) {\n        this.rangeParam(value, \"end_offset\", \"eo\");\n        return this;\n    }\n    fallbackContent(value) {\n        this.param(value, \"fallback_content\");\n        return this;\n    }\n    fetchFormat(value) {\n        this.param(value, \"fetch_format\", \"f\");\n        return this;\n    }\n    format(value) {\n        this.param(value, \"format\");\n        return this;\n    }\n    flags(value) {\n        this.arrayParam(value, \"flags\", \"fl\", \".\");\n        return this;\n    }\n    gravity(value) {\n        this.param(value, \"gravity\", \"g\");\n        return this;\n    }\n    fps(value) {\n        return this.param(value, \"fps\", \"fps\", (fps) => {\n            if (isString(fps)) {\n                return fps;\n            }\n            else if (Array.isArray(fps)) {\n                return fps.join(\"-\");\n            }\n            else {\n                return fps;\n            }\n        });\n    }\n    height(value) {\n        return this.param(value, \"height\", \"h\", () => {\n            if (this.getValue(\"crop\") || this.getValue(\"overlay\") || this.getValue(\"underlay\")) {\n                return Expression.normalize(value);\n            }\n            else {\n                return null;\n            }\n        });\n    }\n    htmlHeight(value) {\n        this.param(value, \"html_height\");\n        return this;\n    }\n    htmlWidth(value) {\n        this.param(value, \"html_width\");\n        return this;\n    }\n    if(value = \"\") {\n        var i, ifVal, j, ref, trIf, trRest;\n        switch (value) {\n            case \"else\":\n                this.chain();\n                return this.param(value, \"if\", \"if\");\n            case \"end\":\n                this.chain();\n                for (i = j = ref = this.chained.length - 1; j >= 0; i = j += -1) {\n                    ifVal = this.chained[i].getValue(\"if\");\n                    if (ifVal === \"end\") {\n                        break;\n                    }\n                    else if (ifVal != null) {\n                        trIf = Transformation.new().if(ifVal);\n                        this.chained[i].remove(\"if\");\n                        trRest = this.chained[i];\n                        this.chained[i] = Transformation.new().transformation([trIf, trRest]);\n                        if (ifVal !== \"else\") {\n                            break;\n                        }\n                    }\n                }\n                return this.param(value, \"if\", \"if\");\n            case \"\":\n                return Condition.new().setParent(this);\n            default:\n                return this.param(value, \"if\", \"if\", (value) => {\n                    return Condition.new(value).toString();\n                });\n        }\n    }\n    keyframeInterval(value) {\n        this.param(value, \"keyframe_interval\", \"ki\");\n        return this;\n    }\n    ocr(value) {\n        this.param(value, \"ocr\", \"ocr\");\n        return this;\n    }\n    offset(value) {\n        var end_o, start_o;\n        [start_o, end_o] = (isFunction(value != null ? value.split : void 0)) ? value.split('..') : Array.isArray(value) ? value : [null, null];\n        if (start_o != null) {\n            this.startOffset(start_o);\n        }\n        if (end_o != null) {\n            return this.endOffset(end_o);\n        }\n    }\n    opacity(value) {\n        this.param(value, \"opacity\", \"o\", Expression.normalize);\n        return this;\n    }\n    overlay(value) {\n        this.layerParam(value, \"overlay\", \"l\");\n        return this;\n    }\n    page(value) {\n        this.param(value, \"page\", \"pg\");\n        return this;\n    }\n    poster(value) {\n        this.param(value, \"poster\");\n        return this;\n    }\n    prefix(value) {\n        this.param(value, \"prefix\", \"p\");\n        return this;\n    }\n    quality(value) {\n        this.param(value, \"quality\", \"q\", Expression.normalize);\n        return this;\n    }\n    radius(value) {\n        this.arrayParam(value, \"radius\", \"r\", \":\", Expression.normalize);\n        return this;\n    }\n    rawTransformation(value) {\n        this.rawParam(value, \"raw_transformation\");\n        return this;\n    }\n    size(value) {\n        let height, width;\n        if (isFunction(value != null ? value.split : void 0)) {\n            [width, height] = value.split('x');\n            this.width(width);\n            return this.height(height);\n        }\n    }\n    sourceTypes(value) {\n        this.param(value, \"source_types\");\n        return this;\n    }\n    sourceTransformation(value) {\n        return this.param(value, \"source_transformation\");\n    }\n    startOffset(value) {\n        this.rangeParam(value, \"start_offset\", \"so\");\n        return this;\n    }\n    streamingProfile(value) {\n        this.param(value, \"streaming_profile\", \"sp\");\n        return this;\n    }\n    transformation(value) {\n        this.transformationParam(value, \"transformation\", \"t\");\n        return this;\n    }\n    underlay(value) {\n        this.layerParam(value, \"underlay\", \"u\");\n        return this;\n    }\n    variable(name, value) {\n        this.param(value, name, name);\n        return this;\n    }\n    variables(values) {\n        this.arrayParam(values, \"variables\");\n        return this;\n    }\n    videoCodec(value) {\n        this.param(value, \"video_codec\", \"vc\", Param.process_video_params);\n        return this;\n    }\n    videoSampling(value) {\n        this.param(value, \"video_sampling\", \"vs\");\n        return this;\n    }\n    width(value) {\n        this.param(value, \"width\", \"w\", () => {\n            if (this.getValue(\"crop\") || this.getValue(\"overlay\") || this.getValue(\"underlay\")) {\n                return Expression.normalize(value);\n            }\n            else {\n                return null;\n            }\n        });\n        return this;\n    }\n    x(value) {\n        this.param(value, \"x\", \"x\", Expression.normalize);\n        return this;\n    }\n    y(value) {\n        this.param(value, \"y\", \"y\", Expression.normalize);\n        return this;\n    }\n    zoom(value) {\n        this.param(value, \"zoom\", \"z\", Expression.normalize);\n        return this;\n    }\n}\n/**\n * Transformation Class methods.\n * This is a list of the parameters defined in Transformation.\n * Values are camelCased.\n */\nconst methods = [\n    \"angle\",\n    \"audioCodec\",\n    \"audioFrequency\",\n    \"aspectRatio\",\n    \"background\",\n    \"bitRate\",\n    \"border\",\n    \"color\",\n    \"colorSpace\",\n    \"crop\",\n    \"customFunction\",\n    \"customPreFunction\",\n    \"defaultImage\",\n    \"delay\",\n    \"density\",\n    \"duration\",\n    \"dpr\",\n    \"effect\",\n    \"else\",\n    \"endIf\",\n    \"endOffset\",\n    \"fallbackContent\",\n    \"fetchFormat\",\n    \"format\",\n    \"flags\",\n    \"gravity\",\n    \"fps\",\n    \"height\",\n    \"htmlHeight\",\n    \"htmlWidth\",\n    \"if\",\n    \"keyframeInterval\",\n    \"ocr\",\n    \"offset\",\n    \"opacity\",\n    \"overlay\",\n    \"page\",\n    \"poster\",\n    \"prefix\",\n    \"quality\",\n    \"radius\",\n    \"rawTransformation\",\n    \"size\",\n    \"sourceTypes\",\n    \"sourceTransformation\",\n    \"startOffset\",\n    \"streamingProfile\",\n    \"transformation\",\n    \"underlay\",\n    \"variable\",\n    \"variables\",\n    \"videoCodec\",\n    \"videoSampling\",\n    \"width\",\n    \"x\",\n    \"y\",\n    \"zoom\"\n];\n/**\n * Parameters that are filtered out before passing the options to an HTML tag.\n *\n * The list of parameters is a combination of `Transformation::methods` and `Configuration::CONFIG_PARAMS`\n */\nconst PARAM_NAMES = methods.map(snakeCase).concat(CONFIG_PARAMS);\nexport default Transformation;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}